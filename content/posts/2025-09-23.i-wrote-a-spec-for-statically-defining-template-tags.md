---
title: I Wrote a Spec for Statically Defining Django Template Tags
summary: I did what now? What does that even mean? Hey, hey! Where are you going?
date: 2025-09-23
---

Given this basic Django template:

```htmldjango
{% extends "base.html" %}

{% block content %}
    {% if user.is_authenticated %}
        <h1>Hello, {{ user.username }}!</h1>
    {% else %}
        <h1>Hello, stranger!</h1>
    {% endif %}
{% endblock content %}
```

I have a simple question. How would you validate that the syntax is correct?

A wrinkle: you cannot import and use the Python or Django runtime, it needs to be statically validated.

Most answers lean on the runtime: load settings, compile the template, and let Django throw `TemplateSyntaxError` whenever you slip. That’s fine when you already have a database, Redis, and every app wired together. It crumbles when you want fast feedback in CI, or you’re authoring tooling that needs to lint a template in isolation without booting half a stack.

So how hard could a static checker be? Start with Django’s built-ins, write down the rules by hand, and let the linter pattern-match against them. Surely that gets you most of the way there.

Consider the `{% block %}` tag. Both of these forms are legal:

```django
{% block content %}
    ...
{% endblock %}

{% block content %}
    ...
{% endblock content %}
```

In my first naive pass, I hard-coded those two shapes. That worked until the next tag needed positional shorthands, optional intermediates, or depended on state baked into Django’s parser. Even the supposedly straightforward `block` tag hides a bunch of logic in `django.template.loader_tags.do_block`: it tracks duplicate blocks, parses the closing token, and throws if the optional name doesn’t match. Replicating that behavior statically meant re-implementing Django’s parser a piece at a time—and that was just for the built-ins.

The deeper problem is how much freedom Django gives tag authors. The parser hands each tag a slice of tokens and backs away; the tag is free to split strings, stash state, and interpret arguments however it likes as long as rendering eventually returns a string. Even the name of the closing tag is just convention. Trying to reverse-engineer those rules statically means either hard-coding every tag’s quirks or executing importer code that was never meant to run during linting.

I ran straight into that wall while building [django-language-server](https://github.com/joshuadavidthomas/django-language-server). Re-implementing the built-ins felt sketchy, but letting third-party tags stay opaque felt worse. What I really needed was a contract: give the tooling the tag’s name, its arguments, whether it spans a block, and how the closing tag should look, and it can do the rest.

So I wrote that contract down. I call them “tagspecs”: a small, declarative manifest that lists the tags a library provides, the arguments they accept, and the block structure they expect. With that in hand, a validator can parse templates, match usage, and surface helpful errors long before anything hits production. The rest of this post is the story of that spec—why it exists, the problems it solves, and how you can use it to make your own tooling sharper.
